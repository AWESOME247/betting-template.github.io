import{r as y,O as _,P as g,Q as m,R as P,u as x,E as b,S as w,T as O}from"./entry.dbc4c8b3.js";const C=()=>null;function E(...i){const l=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(l);let[a,u,n={}]=i;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");n.server=n.server??!0,n.default=n.default??C,n.lazy=n.lazy??!1,n.immediate=n.immediate??!0;const e=x(),f=()=>e.isHydrating?e.payload.data[a]:e.static.data[a],d=()=>f()!==void 0;e._asyncData[a]||(e._asyncData[a]={data:y(f()??n.default()),pending:y(!d()),error:_(e.payload._errors,a),status:y("idle")});const t={...e._asyncData[a]};t.refresh=t.execute=(s={})=>{if(e._asyncDataPromises[a]){if(s.dedupe===!1)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if((s._initial||e.isHydrating&&s._initial!==!1)&&d())return f();t.pending.value=!0,t.status.value="pending";const c=new Promise((r,o)=>{try{r(u(e))}catch(D){o(D)}}).then(r=>{if(c.cancelled)return e._asyncDataPromises[a];let o=r;n.transform&&(o=n.transform(r)),n.pick&&(o=k(o,n.pick)),t.data.value=o,t.error.value=null,t.status.value="success"}).catch(r=>{if(c.cancelled)return e._asyncDataPromises[a];t.error.value=r,t.data.value=b(n.default()),t.status.value="error"}).finally(()=>{c.cancelled||(t.pending.value=!1,e.payload.data[a]=t.data.value,t.error.value&&(e.payload._errors[a]=w(t.error.value)),delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=c,e._asyncDataPromises[a]};const p=()=>t.refresh({_initial:!0}),v=n.server!==!1&&e.payload.serverRendered;{const s=O();if(s&&!s._nuxtOnBeforeMountCbs){s._nuxtOnBeforeMountCbs=[];const r=s._nuxtOnBeforeMountCbs;s&&(g(()=>{r.forEach(o=>{o()}),r.splice(0,r.length)}),m(()=>r.splice(0,r.length)))}v&&e.isHydrating&&d()?(t.pending.value=!1,t.status.value=t.error.value?"error":"success"):s&&(e.payload.serverRendered&&e.isHydrating||n.lazy)&&n.immediate?s._nuxtOnBeforeMountCbs.push(p):n.immediate&&p(),n.watch&&P(n.watch,()=>t.refresh());const c=e.hook("app:data:refresh",r=>{if(!r||r.includes(a))return t.refresh()});s&&m(c)}const h=Promise.resolve(e._asyncDataPromises[a]).then(()=>t);return Object.assign(h,t),h}function k(i,l){const a={};for(const u of l)a[u]=i[u];return a}const M="https://effervescent-manatee-1c0863.netlify.app/.netlify/functions/index/betting/";export{M as a,E as u};
